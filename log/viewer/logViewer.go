// Copyright (c) 2013 - Michael Woolnough <michael.woolnough@gmail.com>
// 
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met: 
// 
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer. 
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution. 
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Log Viewer reads the binary logs generated by webserver/log
package main

import (
	"bytes"
	"compress/gzip"
	"encoding/binary"
	"flag"
	"fmt"
	"io"
	"net"
	"os"
	"strings"
	"time"
)

type log struct {
	logLength uint16
	version   byte
	sTime     int64
	eTime     int64
	addr      net.IP
	port      uint16
	httpData  byte
	status    uint16
	length    uint64
	dataLen   uint16
	url       string
	host      string
	username  string
	ua        string
}

var logName *string = flag.String("f", "", "Access log filename.")

func main() {
	flag.Parse()
	if *logName == "" {
		fmt.Fprintln(os.Stderr, "No log specified")
		os.Exit(1)
	}
	file, err := os.Open(*logName)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error while opening log: ", err)
		os.Exit(2)
	}
	// 	var position int64
	for {
		var thisLog log
		err = binary.Read(file, binary.LittleEndian, &thisLog.logLength)
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Fprintln(os.Stderr, "Error while reading length: ", err)
			os.Exit(3)
		}
		fmt.Println("Log Length: ", thisLog.logLength)
		err = binary.Read(file, binary.LittleEndian, &thisLog.version)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading version: ", err)
			os.Exit(3)
		}
		fmt.Println("Version: ", thisLog.version)
		err = binary.Read(file, binary.LittleEndian, &thisLog.sTime)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading Start Time: ", err)
			os.Exit(3)
		}
		fmt.Println("Start Time: ", time.Unix(0, thisLog.sTime))
		err = binary.Read(file, binary.LittleEndian, &thisLog.eTime)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading End Time: ", err)
			os.Exit(3)
		}
		fmt.Println("End Time: ", time.Unix(0, thisLog.eTime))
		thisLog.addr = net.IP(make([]byte, 16, 16))
		err = binary.Read(file, binary.LittleEndian, &thisLog.addr)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading Address: ", err)
			os.Exit(3)
		}
		fmt.Println("Address: ", thisLog.addr)
		err = binary.Read(file, binary.LittleEndian, &thisLog.port)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading Port: ", err)
			os.Exit(3)
		}
		fmt.Println("Port: ", thisLog.port)
		err = binary.Read(file, binary.LittleEndian, &thisLog.httpData)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading HTTP Data: ", err)
			os.Exit(3)
		}
		err = binary.Read(file, binary.LittleEndian, &thisLog.status)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading Status: ", err)
			os.Exit(3)
		}
		fmt.Println("Status: ", thisLog.status)
		err = binary.Read(file, binary.LittleEndian, &thisLog.length)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading written written length: ", err)
			os.Exit(3)
		}
		fmt.Println("Written Data Length: ", thisLog.length)
		err = binary.Read(file, binary.LittleEndian, &thisLog.dataLen)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading compressed data length: ", err)
			os.Exit(3)
		}
		fmt.Println("Compressed Data Length: ", thisLog.dataLen)
		compressed, err := gzip.NewReader(io.LimitReader(file, int64(thisLog.dataLen)))
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error while reading compressed data: ", err)
			os.Exit(3)
		}
		var buf bytes.Buffer
		io.Copy(&buf, compressed)
		compressed.Close()
		textData := buf.Bytes()
		splitData := strings.SplitN(string(textData), "\000", 4)
		if len(splitData) != 4 {
			fmt.Fprintln(os.Stderr, "Error while reading text data: Wrong Count")
			os.Exit(3)
		}
		thisLog.url = splitData[0]
		thisLog.host = splitData[1]
		thisLog.username = splitData[2]
		thisLog.ua = splitData[3]
		fmt.Println(thisLog.url)
		fmt.Println(thisLog.host)
		fmt.Println(thisLog.username)
		fmt.Println(thisLog.ua)
		fmt.Println("")
	}
}
